<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Interactive Water Texture</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.sound.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script>
        let ripples = [];
        let waterSound;
        let soundLoaded = false;

        function preload() {
            // Load your water ripple sound file
            waterSound = loadSound('waterripple.wav',
                () => {
                    soundLoaded = true;
                    console.log('Water sound loaded successfully!');
                },
                (err) => {
                    console.error('Error loading sound:', err);
                    soundLoaded = false;
                }
            );
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);

            // Create a simple water drop sound using oscillator
            userStartAudio();
        }

        function draw() {
            // Pool water blue gradient
            setGradient(0, 0, width, height, color(0, 140, 200), color(0, 100, 160));

            // Beautiful caustic light patterns like pool bottom
            drawPoolCaustics();

            // Update and draw all ripples
            for (let i = ripples.length - 1; i >= 0; i--) {
                ripples[i].update();
                ripples[i].display();

                // Remove ripples that are done
                if (ripples[i].isDone()) {
                    ripples.splice(i, 1);
                }
            }

            // Subtle shimmer on ripples
            drawMinimalShimmer();
        }

        function touchStarted() {
            // Create ripple at touch point
            ripples.push(new Ripple(mouseX, mouseY));

            // Play water sound
            playWaterSound();

            return false; // Prevent default
        }

        function mousePressed() {
            // Also work with mouse for desktop testing
            ripples.push(new Ripple(mouseX, mouseY));
            playWaterSound();
        }

        function playWaterSound() {
            // Play your custom water sound
            if (soundLoaded && waterSound) {
                // Add slight pitch variation for natural feel
                let rate = random(0.9, 1.1);
                waterSound.rate(rate);

                // Add slight volume variation
                let vol = random(0.7, 1.0);
                waterSound.setVolume(vol);

                waterSound.play();
            } else {
                console.log('Sound not loaded yet');
            }
        }

        function setGradient(x, y, w, h, c1, c2) {
            noFill();
            for (let i = y; i <= y + h; i++) {
                let inter = map(i, y, y + h, 0, 1);
                let c = lerpColor(c1, c2, inter);
                stroke(c);
                line(x, i, x + w, i);
            }
        }

        function drawPoolCaustics() {
            // Realistic pool caustics - interconnected light network
            push();

            // Create interconnected web of light
            noFill();

            // Multiple layers of wavy mesh
            let resolution = 70;

            // Horizontal waves
            strokeWeight(2);

            for (let y = 0; y < height + resolution; y += resolution) {
                beginShape();
                for (let x = 0; x <= width; x += 8) {
                    let wave1 = sin((x * 0.012) + (y * 0.008) + frameCount * 0.01) * 6;
                    let wave2 = cos((x * 0.008) + (y * 0.012) + frameCount * 0.008) * 4;

                    // Fade out towards edges
                    let edgeFade = 1;
                    let distFromEdgeX = min(x, width - x);
                    let distFromEdgeY = min(y, height - y);
                    let distFromEdge = min(distFromEdgeX, distFromEdgeY);

                    if (distFromEdge < 100) {
                        edgeFade = map(distFromEdge, 0, 100, 0, 1);
                    }

                    stroke(255, 255, 255, 140 * edgeFade);

                    // Add ripple distortion
                    let rippleDistortion = 0;
                    for (let ripple of ripples) {
                        let d = dist(x, y, ripple.x, ripple.y);
                        let rippleRadius = ripple.diameter / 2;

                        if (d < rippleRadius + 80) {
                            let influence = map(d, 0, rippleRadius + 80, 1, 0);
                            let rippleWave = sin(d * 0.08 - ripple.diameter * 0.12) * 20 * influence;
                            rippleDistortion += rippleWave;
                        }
                    }

                    let py = y + wave1 + wave2 + rippleDistortion;
                    vertex(x, py);
                }
                endShape();
            }

            // Vertical waves - creates the mesh
            for (let x = 0; x < width + resolution; x += resolution) {
                beginShape();
                for (let y = 0; y <= height; y += 8) {
                    let wave1 = sin((y * 0.012) + (x * 0.008) + frameCount * 0.01) * 6;
                    let wave2 = cos((y * 0.008) + (x * 0.012) + frameCount * 0.008) * 4;

                    // Fade out towards edges
                    let edgeFade = 1;
                    let distFromEdgeX = min(x, width - x);
                    let distFromEdgeY = min(y, height - y);
                    let distFromEdge = min(distFromEdgeX, distFromEdgeY);

                    if (distFromEdge < 100) {
                        edgeFade = map(distFromEdge, 0, 100, 0, 1);
                    }

                    stroke(255, 255, 255, 140 * edgeFade);

                    // Add ripple distortion
                    let rippleDistortion = 0;
                    for (let ripple of ripples) {
                        let d = dist(x, y, ripple.x, ripple.y);
                        let rippleRadius = ripple.diameter / 2;

                        if (d < rippleRadius + 80) {
                            let influence = map(d, 0, rippleRadius + 80, 1, 0);
                            let rippleWave = cos(d * 0.08 - ripple.diameter * 0.12) * 20 * influence;
                            rippleDistortion += rippleWave;
                        }
                    }

                    let px = x + wave1 + wave2 + rippleDistortion;
                    vertex(px, y);
                }
                endShape();
            }

            pop();
        }

        function drawMinimalShimmer() {
            // Only add shimmer on active ripples
            push();
            noStroke();

            for (let ripple of ripples) {
                // Only shimmer on fresh ripples
                if (ripple.diameter < 100) {
                    for (let i = 0; i < 3; i++) {
                        let angle = random(TWO_PI);
                        let dist = random(ripple.diameter * 0.3, ripple.diameter * 0.5);
                        let x = ripple.x + cos(angle) * dist;
                        let y = ripple.y + sin(angle) * dist;

                        let life = map(ripple.diameter, 0, 100, 1, 0);

                        fill(255, 255, 255, life * random(80, 150));
                        ellipse(x, y, random(1, 2.5), random(1, 2.5));
                    }
                }
            }
            pop();
        }

        class Ripple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.diameter = 0;
                this.maxDiameter = 500;
                this.speed = 2.5;
                this.opacity = 255;
                this.rings = 3;
            }

            update() {
                this.diameter += this.speed;
                this.opacity = map(this.diameter, 0, this.maxDiameter, 255, 0);
            }

            display() {
                push();
                noFill();

                // Draw multiple expanding rings with realistic water look
                for (let i = 0; i < this.rings; i++) {
                    let offset = i * 40;
                    let ringDiameter = this.diameter - offset;

                    if (ringDiameter > 0) {
                        let ringOpacity = map(ringDiameter, 0, this.maxDiameter, this.opacity, 0);

                        // Outer glow
                        strokeWeight(6);
                        stroke(80, 150, 220, ringOpacity * 0.3);
                        this.drawWavyCircle(ringDiameter);

                        // Main ring - brighter
                        strokeWeight(3);
                        stroke(120, 200, 255, ringOpacity * 0.7);
                        this.drawWavyCircle(ringDiameter);

                        // Inner highlight
                        strokeWeight(1.5);
                        stroke(180, 230, 255, ringOpacity);
                        this.drawWavyCircle(ringDiameter * 0.98);
                    }
                }

                // Draw splash particles with more realistic motion
                if (this.diameter < 80) {
                    this.drawSplash();
                }

                pop();
            }

            drawWavyCircle(diameter) {
                // Add organic wave distortion to circles
                beginShape();
                for (let a = 0; a < TWO_PI; a += 0.08) {
                    // Multiple wave frequencies for natural look
                    let wave1 = sin(a * 6 + frameCount * 0.15 + this.x * 0.01) * 2;
                    let wave2 = cos(a * 10 + frameCount * 0.1 + this.y * 0.01) * 1.5;
                    let wave3 = sin(a * 15 + this.diameter * 0.05) * 1;

                    let r = diameter / 2 + wave1 + wave2 + wave3;
                    let px = this.x + cos(a) * r;
                    let py = this.y + sin(a) * r;
                    vertex(px, py);
                }
                endShape(CLOSE);
            }

            drawSplash() {
                push();
                noStroke();

                // Main splash droplets
                for (let i = 0; i < 12; i++) {
                    let angle = (TWO_PI / 12) * i;
                    let distance = this.diameter * 0.4;
                    let px = this.x + cos(angle) * distance;
                    let py = this.y + sin(angle) * distance;
                    let size = map(this.diameter, 0, 80, 10, 3);

                    // Droplet with gradient effect
                    fill(180, 230, 255, this.opacity * 0.8);
                    ellipse(px, py, size, size * 1.3);

                    // Highlight on droplet
                    fill(220, 245, 255, this.opacity);
                    ellipse(px - size * 0.2, py - size * 0.2, size * 0.4, size * 0.4);
                }

                // Center burst
                fill(200, 240, 255, this.opacity * 0.6);
                ellipse(this.x, this.y, this.diameter * 0.3, this.diameter * 0.3);

                // Bright center highlight
                fill(240, 250, 255, this.opacity);
                ellipse(this.x, this.y, this.diameter * 0.15, this.diameter * 0.15);

                pop();
            }

            isDone() {
                return this.diameter > this.maxDiameter;
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>

</html>